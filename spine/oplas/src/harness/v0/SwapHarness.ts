/**
 * Swap Harness
 * 
 * Core post-LLM proof: runs test suite with different model configurations.
 * 
 * Version: 1.0.0
 */

import { IModelAdapter } from '../../model/v0/ModelAdapter';
import { Request } from '../../contracts/types/Request';
import { RunSummary } from '../../orchestrator/v0/types';
import { runTask } from '../../orchestrator/v0/Orchestrator';
import { ReplayModelAdapter } from '../../model/v0/ReplayAdapter';
import { StubModelAdapter } from '../../model/v0/StubAdapter';

/**
 * Swap mode.
 */
export enum SwapMode {
  MODEL_A = 'MODEL_A',
  MODEL_B = 'MODEL_B',
  A_THEN_B = 'A_THEN_B',
  NO_MODEL = 'NO_MODEL'
}

/**
 * Suite task definition.
 */
export interface SuiteTask {
  /** Task ID */
  task_id: string;
  /** Request */
  request: Request;
  /** Input grid */
  input_grid: number[][];
  /** Expected output grid (optional) */
  expected_output_grid?: number[][];
}

/**
 * Test suite definition.
 */
export interface TestSuite {
  /** Suite name */
  name: string;
  /** Suite description */
  description?: string;
  /** Tasks */
  tasks: SuiteTask[];
  /** Fixed seed (optional) */
  seed?: number;
  /** Vault snapshot hash (optional) */
  vault_hash?: string;
}

/**
 * Suite run report.
 */
export interface SuiteReport {
  /** Suite name */
  suite_name: string;
  /** Swap mode */
  mode: SwapMode;
  /** Run timestamp */
  timestamp_iso: string;
  /** Task results */
  task_results: TaskResult[];
  /** Aggregate metrics */
  metrics: SuiteMetrics;
}

/**
 * Task result.
 */
export interface TaskResult {
  /** Task ID */
  task_id: string;
  /** Solved (pass tiers 0-2) */
  solved: boolean;
  /** Tier 3 pass */
  tier3_pass: boolean;
  /** Winner program ID */
  winner_program_id?: string;
  /** Winner cost C */
  winner_cost_C?: number;
  /** Tokens used */
  tokens?: number;
  /** Cost USD */
  cost_usd?: number;
  /** Latency ms */
  latency_ms?: number;
  /** Proposals used */
  proposals_used?: number;
  /** Repairs used */
  repairs_used?: number;
  /** Vault hits */
  vault_hits?: number;
  /** Negative evidence written */
  negative_evidence_written?: number;
  /** Top failure code */
  top_failure_code?: string;
  /** Error (if failed) */
  error?: string;
}

/**
 * Suite metrics.
 */
export interface SuiteMetrics {
  /** Solve rate (pass tiers 0-2) */
  solve_rate: number;
  /** Writeback rate (pass tier 3 + wrote concept) */
  writeback_rate: number;
  /** Average cost USD */
  avg_cost_usd: number;
  /** P95 cost USD */
  p95_cost_usd: number;
  /** Average latency ms */
  avg_latency_ms: number;
  /** Concept reuse rate */
  concept_reuse_rate: number;
  /** Negative evidence rate */
  negative_evidence_rate: number;
  /** Failure mode histogram */
  failure_mode_histogram: Record<string, number>;
}

/**
 * Runs a test suite with specified swap mode.
 */
export async function runSuite(
  suite: TestSuite,
  mode: SwapMode,
  options: {
    taskRoot: string;
    modelA?: IModelAdapter;
    modelB?: IModelAdapter;
    vaultRoot?: string;
  }
): Promise<SuiteReport> {
  const taskResults: TaskResult[] = [];
  const failureModes: Record<string, number> = {};

  for (const task of suite.tasks) {
    try {
      let modelAdapter: IModelAdapter | undefined;
      let runId: string | undefined;

      // Select model adapter based on mode
      switch (mode) {
        case SwapMode.MODEL_A:
          modelAdapter = options.modelA;
          break;
        case SwapMode.MODEL_B:
          modelAdapter = options.modelB;
          break;
        case SwapMode.A_THEN_B:
          // For A_THEN_B, we'd need a composite adapter
          // For now, use MODEL_A (can be enhanced later)
          modelAdapter = options.modelA;
          break;
        case SwapMode.NO_MODEL:
          // Use stub adapter (fixtures + vault + enumerator)
          modelAdapter = new StubModelAdapter();
          break;
      }

      // Run task
      const summary = await runTask(
        task.request,
        [], // Candidates (will be generated by model adapter if provided)
        {
          grid: task.input_grid,
          examples: task.expected_output_grid ? [{
            input_grid: task.input_grid,
            expected_output_grid: task.expected_output_grid
          }] : undefined
        },
        options.taskRoot,
        {
          vaultRoot: options.vaultRoot,
          modelAdapter,
          enableRefinement: mode !== SwapMode.NO_MODEL
        }
      );

      // Extract metrics from summary
      const taskResult: TaskResult = {
        task_id: task.task_id,
        solved: summary.ok,
        tier3_pass: summary.winner_result?.verifier_result?.tier3_pass || false,
        winner_program_id: summary.winner_program_id,
        winner_cost_C: summary.winner_result?.cost_breakdown?.total_cost,
        proposals_used: summary.candidates_evaluated,
        repairs_used: 0, // TODO: Extract from summary
        vault_hits: 0, // TODO: Extract from summary
        negative_evidence_written: 0, // TODO: Extract from summary
        top_failure_code: summary.failure_reason
      };

      // Extract cost/latency from model calls (if available)
      // TODO: Load model calls and aggregate

      taskResults.push(taskResult);

      // Track failure modes
      if (!summary.ok && summary.failure_reason) {
        failureModes[summary.failure_reason] = (failureModes[summary.failure_reason] || 0) + 1;
      }
    } catch (error) {
      taskResults.push({
        task_id: task.task_id,
        solved: false,
        tier3_pass: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      failureModes['execution_error'] = (failureModes['execution_error'] || 0) + 1;
    }
  }

  // Compute aggregate metrics
  const solvedCount = taskResults.filter(r => r.solved).length;
  const writebackCount = taskResults.filter(r => r.tier3_pass).length;
  const costs = taskResults.map(r => r.cost_usd || 0).filter(c => c > 0);
  const latencies = taskResults.map(r => r.latency_ms || 0).filter(l => l > 0);

  const metrics: SuiteMetrics = {
    solve_rate: taskResults.length > 0 ? solvedCount / taskResults.length : 0,
    writeback_rate: taskResults.length > 0 ? writebackCount / taskResults.length : 0,
    avg_cost_usd: costs.length > 0 ? costs.reduce((a, b) => a + b, 0) / costs.length : 0,
    p95_cost_usd: costs.length > 0 ? costs.sort((a, b) => a - b)[Math.floor(costs.length * 0.95)] : 0,
    avg_latency_ms: latencies.length > 0 ? latencies.reduce((a, b) => a + b, 0) / latencies.length : 0,
    concept_reuse_rate: 0, // TODO: Compute from vault hits
    negative_evidence_rate: 0, // TODO: Compute from negative evidence
    failure_mode_histogram: failureModes
  };

  return {
    suite_name: suite.name,
    mode,
    timestamp_iso: new Date().toISOString(),
    task_results: taskResults,
    metrics
  };
}























